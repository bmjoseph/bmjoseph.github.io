<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.53" />


<title>Intro to Web Scraping - Blog_Name</title>
<meta property="og:title" content="Intro to Web Scraping - Blog_Name">



  








<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="https://github.com/bmjoseph">GitHub</a></li>
    
    <li><a href="https://twitter.com/rstudio">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">22 min read</span>
    

    <h1 class="article-title">Intro to Web Scraping</h1>

    
    <span class="article-date">2017/11/18</span>
    

    <div class="article-content">
      

<div id="TOC">
<ul>
<li><a href="#introduction-and-motivation">Introduction and Motivation</a></li>
<li><a href="#reading-web-data-into-r">Reading Web Data into R</a><ul>
<li><a href="#background-about-html">Background About HTML</a></li>
<li><a href="#using-the-package-rvest">Using the Package Rvest</a></li>
</ul></li>
<li><a href="#song-lyric-analysis">Song Lyric Analysis</a><ul>
<li><a href="#data-cleaning-with-stringr">Data Cleaning with Stringr</a></li>
<li><a href="#scraping-and-cleaning-more-lyrics-for-analysis">Scraping and Cleaning More Lyrics for Analysis</a></li>
<li><a href="#analysis-of-repetition">Analysis of Repetition</a></li>
</ul></li>
<li><a href="#making-word-clouds-from-song-lyrics">Making Word Clouds from Song Lyrics</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#reproducibility">Reproducibility</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

<pre class="r"><code>library(rvest) # For web mining
library(stringr) # For cleaning Strings
library(dplyr) # For manipulating data frames
library(tm) # For text operations necessary to create a word cloud
library(wordcloud) # For creating a word cloud
library(ggplot2) # For producing visualizations</code></pre>
<div id="introduction-and-motivation" class="section level1">
<h1>Introduction and Motivation</h1>
<p>We’ve developed a large toolbox for working with and analyzing strings, but so far we’ve been restricted to looking at strings that we either type out by hand or are easily imported as rows and columns in a csv or other spreadsheet format. Of course, there’s lots of interesting data that exists outside of already established spreadsheets – think about the power of being able to pull text data directly from online sources. This allows our power as a data scientist to extend past doing research on data that was, in a sense, prepared specifically <em>for</em> data analysis by whoever originally created the spreadsheet. It can be hard to find data in a spreadsheet that will allow you to perform an analysis that is truly new.</p>
<p>Web mining is actually similar in many ways to gold mining. First, there’s a huge digital landscape to scour. It’s easy to get lost in the <a href="https://www.theatlantic.com/technology/archive/2015/09/how-many-websites-are-there/408151/">over one billion</a> accessible websites. Even once you’ve narrowed your search down to a location on the web that you believe has valuable information, trying to take all of it is akin to bringing home a whole plot of land. You’ll quickly become bogged down with data that contains mostly dirt and is hard to use for anything practical. Luckily, web mining also shares the positives of gold mining – with the proper techniques and some practice, you’ll be able to strike it rich with a nugget of gold – a brand new dataset.</p>
<p>I plan to show you some of these techniques to allow you to take text data from online sources. I’ll be specifically working with song lyrics, but you can easily extend the principles to be able to take data from news articles, social media posts, and even other blog posts like this!</p>
</div>
<div id="reading-web-data-into-r" class="section level1">
<h1>Reading Web Data into R</h1>
<div id="background-about-html" class="section level3">
<h3>Background About HTML</h3>
<p>At a basic level, all websites are written in HTML, or Hypertext Markup Language. Every time you load a website, your browser interprets data written in HTML and decides what to display and how to display it. HTML bears some similarities to Markdown. For example, &lt;b&gt;this text would appear bold in HTML.&lt;/b&gt; The characters in angled brackets describe <strong>how</strong> to display text and much like the two asterisks I used to bold the word “how,” are not displayed by default in the final rendered version. I escaped the characters to make this document becuase R Markdown understands HTML formatting and by default would actually bold the example text.</p>
<p>This is important to reading websites because these tags will tell us where to look for the specific information we want. For example, pesky lists of advertiser website hyperlinks are unlikely to be denoted with a &lt;p&gt; (paragraph) tag. But before we get into all those specifics, let’s take a step back and actually load a webpage into R.</p>
</div>
<div id="using-the-package-rvest" class="section level3">
<h3>Using the Package Rvest</h3>
<p>Our main tool for brining web data into a usable format will Hadley Wickham’s package <a href="https://cran.r-project.org/web/packages/rvest/rvest.pdf">Rvest</a>. The first and most basic function to use is <code>read_html()</code> which takes in a url as a string and automatically reads the html contents of the corresponding website into a list.</p>
<p>Let’s try an example! I’ll read in <a href="http://www.songtexte.com/songtext/taylor-swift/all-too-well-53a71b61.html">this website</a> which contains the lyrics to Taylor Swift’s song “All Too Well.”</p>
<p>According to <a href="https://statistics.berkeley.edu/computing/r-reading-webpages">the Berkeley Department of Statistics</a>, the best practice is to always download a local copy of the website you’ll be analyzing. This prevents you from putting unnecessary strain on the website’s server. There are also practical reasons to download your own copy – it takes a while to read and download a website from the internet the first time, but accessing and reading a local copy is very fast. Also, downloading your own copy ensures that you can continue your analysis regardless of the future status of the website. If you lose internet access or the site owners take the content down, you’ll still be able to read the files on your local device.</p>
<p>I’ll use a fairly standard file structure with a data folder. Use the base R <code>download.file</code> function and update the file path according to the structure you prefer for the project you’re working on. This project has two subfolders within data, one called “first_example,” (without the comma) which we will use now, and another called “song_lyrics,” (also without the comma) which we will use later.</p>
<pre class="r"><code>example_song_name &lt;- &quot;All_Too_Well&quot;
example_song_url &lt;- &quot;http://www.songtexte.com/songtext/taylor-swift/all-too-well-53a71b61.html&quot;

# This is commented out because you only have to (and should only) download once

#download.file(url = example_song_url,
              #destfile = paste0(&quot;../../static/data/web_scrape_guide/first_example/&quot;,
               #                 example_song_name))

all_too_well &lt;- read_html(&quot;../../static/data/web_scrape_guide/first_example/All_Too_Well&quot;)

str(all_too_well)</code></pre>
<pre><code>## List of 2
##  $ node:&lt;externalptr&gt; 
##  $ doc :&lt;externalptr&gt; 
##  - attr(*, &quot;class&quot;)= chr [1:2] &quot;xml_document&quot; &quot;xml_node&quot;</code></pre>
<p>Inspecting the structure of the output, we see that we have a list of two items: something of class <code>xml_document</code> and something of class <code>xml_node</code>. Unfortunately, we can’t use this list directly – calling the <code>all_too_well</code> object outputs what looks like nonsense:</p>
<pre class="r"><code>all_too_well</code></pre>
<pre><code>## {xml_document}
## &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
## [1] &lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset= ...
## [2] &lt;body class=&quot;somde&quot;&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--/*--&gt;&lt;![CDA ...</code></pre>
<p>The next step is to use rvest to extract only the components of the webpage that we’re actually interested in using the function <code>html_nodes()</code>. This is probably the most challenging part of the process, as it requires going to the website itself and identifying the HTML tags that describe the part we’re interested in.</p>
<p>If you’re using Google Chrome on a Mac, go to the website and push option command i to automatically open up information about the HTML structure of whatever website you’re on. Chrome on a PC isn’t much different – just use the control key instead of the command key. If you’re on Safari, follow the steps <a href="http://www.socialmeteor.com/2013/03/04/how-to-view-html-source-in-safari-web-browser/">here</a>. If you have a different browser, follow the steps on <a href="https://www.computerhope.com/issues/ch000746.htm">this site</a>.</p>
<p>With that said, I do highly recommend using Google Chrome. Chrome will make the following steps much easier. If you’re following along and using Google Chrome, you should see something like this:</p>
<p><br></p>
<div class="figure">
<img src="../../static/images/web_scrape_guide/img1.png" />

</div>
<p><br></p>
<p>Take special notice of the part that I added a red circle to in upper center part of the picture. That’s a selector tool which will allow you to find your desired HTML tags without first becoming an HTML coding wizard. Click on that tool and then interactively move your cursor around the left part of the screen (without clicking) until the text you want is highlighted. Click once and notice the change on the right hand side. If you do this step correctly and highlight only the lyrics, you should see this line highlighted on the right side of the page:</p>
<p><br></p>
<div class="figure">
<img src="../../static/images/web_scrape_guide/highlighted_tag.png" />

</div>
<p><br></p>
<p>The text is partitioned off in a <code>&lt;div&gt;</code> tag, which means it’s divided from other parts. Looking at the lines above and below the highlighted one though, you’ll see it’s not the only <code>&lt;div&gt;</code> tag. Luckily, the people who set up the page included an ID for this particular tag, which you can see in <code>&lt;div id=&quot;lyrics&quot;&gt;</code>.</p>
<p>We can use the <code>html_nodes()</code> function to capture only the part of the web data contained within this particular tag. This function requires two arguments: the output of a call to <code>read_html()</code> and the id of our desired tag, set off with quotes and a hash symbol. The hash does <strong>not</strong> appear in the id listed on the site, so be careful not to forget it.</p>
<pre class="r"><code>all_too_well_node &lt;- html_nodes(all_too_well, &quot;#lyrics&quot;)
all_too_well_node</code></pre>
<pre><code>## {xml_nodeset (1)}
## [1] &lt;div id=&quot;lyrics&quot;&gt;I walked through the door with you the air was cold ...</code></pre>
<p>This looks much better – already we can see some of the lyrics text, but we still have that pesky {xml_nodeset} hanging around. We can immediately use the function <code>html_text()</code> to extract the text from this node!</p>
<pre class="r"><code>all_too_well_text &lt;- html_text(all_too_well_node)

# This outputs a list with one long element. This next line uses stringr to
# extract only the first 300 characters.

(substr(all_too_well_text[[1]], 1, 300))</code></pre>
<pre><code>## [1] &quot;I walked through the door with you the air was cold\nBut something about it felt like home somehow\nAnd I left my scarf there at your sister&#39;s house\nAnd you still got it in your drawer, even now\nOh, your sweet disposition and my wide-eyed gaze\nWe&#39;re singing in the car getting lost upstate\nAutumn leave&quot;</code></pre>
<p>We’ve done it! The text is clearly there, and now the only problems are that we have “\n” hanging around at any line break and that the contents are in a one element vector instead of a vector of separate words. We’ve done all we can with rvest, and now we’ll use stringr to clean the output and do some analysis!</p>
<div id="a-note-about-finding-tags" class="section level4">
<h4>A Note About Finding Tags</h4>
<p>Hadley Wickham recommends using the Google Chrome extension <a href="https://cran.r-project.org/web/packages/rvest/vignettes/selectorgadget.html">Selector Gadget</a> to find your desired HTML tags. I downloaded version 1.1 here from <a href="https://chrome.google.com/webstore/detail/selectorgadget/mhjhnkcfbdhnjickkkdbjoemdmbfginb">the Chrome extension store</a> and can confirm that it works and didn’t have any adverse effects. With that said, I haven’t used it for any web mining and won’t be going into the details of how it works. Feel free to experiment with it for your own web mining in the future.</p>
</div>
</div>
</div>
<div id="song-lyric-analysis" class="section level1">
<h1>Song Lyric Analysis</h1>
<div id="data-cleaning-with-stringr" class="section level3">
<h3>Data Cleaning with Stringr</h3>
<p>As you may recall, stringr is <a href="https://cran.r-project.org/web/packages/stringr/stringr.pdf">another package</a> written by Hadley Wickham. It’s main purpose is to perform cleaning tasks on data stored as a string. We’ll be using it to remove the “\n” characters from song lyrics and replace them with a space.</p>
<pre class="r"><code># pattern matches all &quot;\n&quot; and changes to a space

all_too_well_clean &lt;- str_replace_all(all_too_well_text,
                                      pattern = &quot;\n&quot;,
                                      replacement = &quot; &quot;)

# taking a look again at the first 300 characters

substr(all_too_well_clean, 1, 300)</code></pre>
<pre><code>## [1] &quot;I walked through the door with you the air was cold But something about it felt like home somehow And I left my scarf there at your sister&#39;s house And you still got it in your drawer, even now Oh, your sweet disposition and my wide-eyed gaze We&#39;re singing in the car getting lost upstate Autumn leave&quot;</code></pre>
<p><strong>Caution:</strong> Make sure to use <code>str_replace_all()</code> instead of <code>str_replace()</code> because we want to catch every instance of the pattern, not just the first example.</p>
<p>It seems like our text data is pretty clean! As a matter of preference, I’m going to separate dashed words into two separate words using the same cleaning method as above. I’ll also remove any commas and periods from the text.</p>
<p>The next step is then to put the data into a vector, with one word per element instead of all words in one element of a list. First, I’ll use the <code>str_split()</code> function to split the single list element every time we encounter a space. Then I’ll use the base R function <code>unlist()</code> to convert the list to a many element vector.</p>
<pre class="r"><code># Separates dashed words into two words

all_too_well_clean &lt;- str_replace_all(all_too_well_clean,
                                      pattern = &quot;-&quot;,
                                      replacement = &quot; &quot;)

# Removes any periods or commas from the data  

all_too_well_clean &lt;- str_replace_all(all_too_well_clean,
                                    pattern = &quot;[\\.,]&quot;, # Character set of . ,
                                    replacement = &quot;&quot;)

# Splits the words into separate elements

all_too_well_clean &lt;- str_split(all_too_well_clean,
                                pattern = &quot; &quot;)

# We now have a one element list with many elements in the first position
# Use the base R function unlist to get this into a vector

all_too_well_clean &lt;- unlist(all_too_well_clean)

# This is a very long vector, so let&#39;s take a look at the head and the length

length(all_too_well_clean)</code></pre>
<pre><code>## [1] 466</code></pre>
<pre class="r"><code>head(all_too_well_clean, 5)</code></pre>
<pre><code>## [1] &quot;I&quot;       &quot;walked&quot;  &quot;through&quot; &quot;the&quot;     &quot;door&quot;</code></pre>
<p>So the song “All Too Well” has 466 words and starts with “I walked through the door.”</p>
<div id="a-note-about-reproducibility" class="section level4">
<h4>A Note about Reproducibility</h4>
<p>I can anticipate the important question: “Hey, what was the point of all that? I had to mess around with HTML and write a bunch of code just to find out the first five words of the song? Couldn’t I just read the lyrics myself or copy paste them in myself? That would be a lot faster!”</p>
<p>It might be true that when harvesting a single song, page, or article, it’s faster to copy paste in the relevant parts. However, as tempting as it is to exercise your control c control v muscles, this process will become time consuming and prone to error over longer projects. It won’t take very much more time to import 10 or 100 songs than it did for one with the coding process (and a for loop), but to do the same with copy and pasting would take 10 and 100 times as long. To demonstrate this, let’s actually read in the lyrics from my favorite and least favorite song from each of Taylor Swift’s <a href="https://en.wikipedia.org/wiki/Taylor_Swift_discography#Studio_albums">studio albums</a>.</p>
</div>
</div>
<div id="scraping-and-cleaning-more-lyrics-for-analysis" class="section level3">
<h3>Scraping and Cleaning More Lyrics for Analysis</h3>
<p>First, I’ll load the names and urls of the songs that I’m interested in analyzing:</p>
<pre class="r"><code># My favorite song from each album: 
favorite_songs &lt;- c(&quot;Should&#39;ve Said No&quot;,
                    &quot;Change&quot;,
                    &quot;Sparks Fly&quot;,
                    &quot;All Too Well&quot;,
                    &quot;Clean&quot;,
                    &quot;Call It What You Want&quot;)

# My least favorite song from each album:
least_favorites &lt;- c(&quot;Mary&#39;s Song&quot;,
                     &quot;The Best Day&quot;,
                     &quot;Mine&quot;,
                     &quot;I Knew You Were Trouble&quot;,
                     &quot;Out of the Woods&quot;,
                     &quot;Look What You Made Me Do&quot;)

# Change the names of the songs to have underscores instead of spaces
favorite_songs &lt;- str_replace_all(favorite_songs,
                                  pattern = &quot; &quot;,
                                  replacement = &quot;_&quot;)
least_favorites &lt;- str_replace_all(least_favorites,
                                   pattern = &quot; &quot;,
                                   replacement = &quot;_&quot;)

# Favorite and least favorite together
song_names &lt;- c(favorite_songs, least_favorites)

# Url for the lyrics of each song 
song_urls &lt;- (
  c(&quot;http://www.songtexte.com/songtext/taylor-swift/shouldve-said-no-4b4ba34a.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/change-3ccd59f.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/sparks-fly-4be8472e.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/all-too-well-53a71b61.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/clean-1b4b8100.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/call-it-what-you-want-g3be734ec.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/marys-song-oh-my-my-my-1b738dc8.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/the-best-day-43cd27b7.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/mine-53ebbb5d.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/i-knew-you-were-trouble-53a71b59.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/out-of-the-woods-5b4a330c.html&quot;,
    &quot;http://www.songtexte.com/songtext/taylor-swift/look-what-you-made-me-do-g13fabd81.html&quot;))</code></pre>
<p>Next, I’ll write a for loop generalizes what I did for “All Too Well” above. The output will be a list of 12 vectors where each element contains the lyrics to one of the songs above.</p>
<p>You’ll notice a fair amount of gymnastics in the code below. In order to extract only the words themselves, we’ll need to remove characters such as <code>,.?!()/\</code> and replace them with the empty string. The problem is that some of those characters are <em>metacharacters</em> instead of literals, which means we can’t substitute them directly into our functions.</p>
<p>To get around this, I’ll escape them using <code>\</code>. The only problem comes from the <code>\</code> character itself, which isn’t quite as easily removed using <code>str_replace_all()</code>. Following the advice of <a href="https://stackoverflow.com/questions/25424382/how-to-replace-single-backslash-in-r">this stack overflow thread</a>, I’ll use the base R function gsub for that.</p>
<p>Finally, I’ll convert everything to lowercase.</p>
<p><strong>Caution:</strong> Make sure your file structure matches mine (a data folder with two subfolders) otherwise these lines of code will not work. Optionally change both your file structure and the file paths in the code.</p>
<pre class="r"><code># Download local copies of the web pages to the data/song_lyrics folder
# Again, this is commented out to avoid spamming their servers. Only download once.

#for (i in 1:length(song_urls)) {
  #download.file(url = song_urls[i],
                #destfile = paste0(&quot;../../static/data/web_scrape_guide/song_lyrics/&quot;, song_names[i]))
#}


# Initialize an empty vector to be filled with lyrics
swift_song_lyrics &lt;- (rep(NA, length(song_names)))

# Read the data from the web source using pipe notation for brevity
for (i in 1:length(song_names)) {
  swift_song_lyrics[i] &lt;- (paste0(&quot;../../static/data/web_scrape_guide/song_lyrics/&quot;, song_names[i]) %&gt;% 
                          read_html() %&gt;%
                          html_nodes(&quot;#lyrics&quot;) %&gt;%
                          html_text() %&gt;%
           # Next we&#39;ll replace new lines and dashes with spaces
                          str_replace_all(pattern = &quot;[\n-]&quot;, 
                                      replacement = &quot; &quot;) %&gt;%
           # Next we&#39;ll replace periods, commas, !, ?, and  parentheses with &quot;&quot;
                          str_replace_all(pattern = &quot;[\\.,!/?()]&quot;,
                                      replacement = &quot;&quot;) %&gt;%
                          str_split(pattern = &quot; &quot;))
}

# Do some additional preprocessing

for (i in 1:length(swift_song_lyrics)) {
  # First change everything to lowercase
  swift_song_lyrics[[i]] &lt;- tolower(swift_song_lyrics[[i]])
  
  # Next remove any double quotations inside words
  swift_song_lyrics[[i]] &lt;- str_replace_all(swift_song_lyrics[[i]], &quot;\&quot;&quot;, &quot;&quot;)
  
  # Finally use gsub to remove the \ characters
  swift_song_lyrics[[i]] &lt;- (gsub(&quot;\\&quot;, &quot;&quot;, swift_song_lyrics[[i]], fixed = TRUE))
}</code></pre>
<p>Let’s take a look at the first 5 words of each song to make sure we have a list of 12 items where each contains lower case separated song words:</p>
<pre class="r"><code>for (i in 1:length(swift_song_lyrics)) {
  print(swift_song_lyrics[[i]][1:5])
}</code></pre>
<pre><code>## [1] &quot;it&#39;s&quot;    &quot;strange&quot; &quot;to&quot;      &quot;think&quot;   &quot;the&quot;    
## [1] &quot;and&quot;     &quot;it&#39;s&quot;    &quot;a&quot;       &quot;sad&quot;     &quot;picture&quot;
## [1] &quot;the&quot;  &quot;way&quot;  &quot;you&quot;  &quot;move&quot; &quot;is&quot;  
## [1] &quot;i&quot;       &quot;walked&quot;  &quot;through&quot; &quot;the&quot;     &quot;door&quot;   
## [1] &quot;the&quot;     &quot;drought&quot; &quot;was&quot;     &quot;the&quot;     &quot;very&quot;   
## [1] &quot;my&quot;        &quot;castle&quot;    &quot;crumbled&quot;  &quot;overnight&quot; &quot;i&quot;        
## [1] &quot;she&quot;   &quot;said&quot;  &quot;i&quot;     &quot;was&quot;   &quot;seven&quot;
## [1] &quot;i&#39;m&quot;   &quot;five&quot;  &quot;years&quot; &quot;old&quot;   &quot;it&#39;s&quot; 
## [1] &quot;you&quot;     &quot;were&quot;    &quot;in&quot;      &quot;college&quot; &quot;working&quot;
## [1] &quot;once&quot; &quot;upon&quot; &quot;a&quot;    &quot;time&quot; &quot;a&quot;   
## [1] &quot;looking&quot; &quot;at&quot;      &quot;it&quot;      &quot;now&quot;     &quot;it&quot;     
## [1] &quot;i&quot;      &quot;don&#39;t&quot;  &quot;like&quot;   &quot;your&quot;   &quot;little&quot;</code></pre>
<p>This looks perfect! Our data is mined and clean, and now we’ve created a workable dataset which will allow us to do some analysis that might not have been done before.</p>
</div>
<div id="analysis-of-repetition" class="section level3">
<h3>Analysis of Repetition</h3>
<p>Let’s see how repetitive each of these songs are. To do this, we’ll use the base r function <code>unique()</code> which takes in a vector (of any type) and returns a vector which contains the same thing as the original but with any duplicate elements removed.</p>
<p>Start by computing the total number of words per song and putting it into a dataframe:</p>
<pre class="r"><code># Initialize a vector of the correct length
total_words_by_song &lt;- rep(0, length(swift_song_lyrics))

# Use a for loop to add the accurate length one song at a time
for (i in 1:length(total_words_by_song)) {
  total_words_by_song[i] &lt;- length(swift_song_lyrics[[i]])
}

# Change song names back to having spaces. This will make the eventual graph nicer

song_names &lt;- str_replace_all(song_names,
                                  pattern = &quot;_&quot;,
                                  replacement = &quot; &quot;)


# Make a dataframe with one row per song: 
song_frame &lt;- data.frame(&quot;Title&quot; = song_names,
                         &quot;Total_Words&quot; = total_words_by_song)

head(song_frame, 5)</code></pre>
<pre><code>##               Title Total_Words
## 1 Should&#39;ve Said No         343
## 2            Change         265
## 3        Sparks Fly         349
## 4      All Too Well         466
## 5             Clean         312</code></pre>
<p>Next, compute the total number of unique words per song and add this to the data frame:</p>
<pre class="r"><code># Initialize a vector of the correct length
unique_words_by_song &lt;- rep(0, length(swift_song_lyrics))

# Use a for loop to add the number of unique words per song
for (i in 1:length(unique_words_by_song)) {
  unique_words_by_song[i] &lt;- length(unique(swift_song_lyrics[[i]]))
}

song_frame$Unique_Words &lt;- unique_words_by_song
head(song_frame, 5)</code></pre>
<pre><code>##               Title Total_Words Unique_Words
## 1 Should&#39;ve Said No         343          107
## 2            Change         265          122
## 3        Sparks Fly         349          129
## 4      All Too Well         466          203
## 5             Clean         312          113</code></pre>
<p>Finally, let’s find the fraction of words per song that are unique. To help with some later analysis, I’ll include a factor that says whether the song is one of my favorites or least favorites and the number of years since 2006, which was when Taylor Swift’s first album was released</p>
<pre class="r"><code># Divide the unique words by the total words for the fraction that are unique
frac_unique &lt;- unique_words_by_song/total_words_by_song

# Add the appropriate column
song_frame$Fraction_Unique &lt;- frac_unique

# Add a column to specify my feelings about the song
feelings &lt;- rep(c(&quot;favorite&quot;, &quot;least favorite&quot;), each = 6)

song_frame$Opinion &lt;- as.factor(feelings)

# Add a column specifying years since 2006
years_since_2006 &lt;- rep(c(0,2,4,6,8,11),2)

song_frame$Years_Since_2006 &lt;- years_since_2006

# Display some rows
slice(song_frame, c(1,2,7,8))</code></pre>
<pre><code>## # A tibble: 4 x 6
##               Title Total_Words Unique_Words Fraction_Unique
##              &lt;fctr&gt;       &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;
## 1 Should&#39;ve Said No         343          107       0.3119534
## 2            Change         265          122       0.4603774
## 3       Mary&#39;s Song         333          148       0.4444444
## 4      The Best Day         348          171       0.4913793
## # ... with 2 more variables: Opinion &lt;fctr&gt;, Years_Since_2006 &lt;dbl&gt;</code></pre>
<p>Finally, let’s use ggplot2 to make a visualization displaying what we’ve found so far:</p>
<pre class="r"><code>gg_song_plot &lt;- (ggplot(data = song_frame,
                        aes(x = Years_Since_2006,
                            y = Fraction_Unique,
                            color = Opinion)) + 
                   geom_point(size = 4) +
                   geom_label(aes(label = Title),
                              alpha = .75,
                              nudge_x = .25,
                              nudge_y = .01,
                              size = 2.5) +
        # This next line ensures the labels aren&#39;t cut off
                   xlim(c(-1, 13)) +
                   labs(title = &quot;Song Word Uniqueness Over Time&quot;,
                         x = &quot;Years Since 2006&quot;,
                         y = &quot;Fraction of Lyrics that are Unique&quot;) +
        # This is totally optional and just to make the plot look better
                    theme(plot.title = element_text(color = &quot;black&quot;,
                                                    size = 14,
                                                    face = &quot;bold.italic&quot;),
                          axis.title.x = element_text(size = 12,
                                                  face = &quot;bold&quot;),
                          axis.title.y = element_text(size = 12,
                                                      face = &quot;bold&quot;)))
gg_song_plot</code></pre>
<p><img src="/post/2017-11-18-intro-to-web-scraping_files/figure-html/create%20a%20plot-1.png" width="672" /></p>
<p>As you can see, on average, the songs I selected have gotten more repetitive over time as Taylor Swift transitioned from country music to pop music. You can also see that I tend not to prefer songs that are very repetitive, as all songs with less than one quarter of their words unique were in my least favorite category.</p>
<p>Let’s see if there’s any relationship between the length of the song and the amount of uniqueness:</p>
<pre class="r"><code># This calculates the correlation between total words and unique words
length_unique_cor &lt;- cor(song_frame$Total_Words, song_frame$Fraction_Unique)

# Calculates the coefficient of determination
length_unique_r2 &lt;- length_unique_cor**2

# Creates the Visualization
gg_len_vs_unique &lt;- (ggplot(data = song_frame,
                        aes(x = Total_Words,
                            y = Fraction_Unique)) + 
                   geom_point(size = 4) +
                   geom_label(aes(label = Title),
                              alpha = .75,
                              nudge_x = .25,
                              nudge_y = .01,
                              size = 2.5) +
                   labs(title = &quot;Song Word Uniqueness Against Length&quot;,
                         x = &quot;Total Words&quot;,
                         y = &quot;Fraction of Lyrics that are Unique&quot;) +
        # This puts in text describing the R^2 value for these variables
                       annotate(&quot;text&quot;, x=575, y=.45, size = 6,
                                label= &quot;italic(R) ^ 2 == .550&quot;, parse = TRUE) +
        # This is totally optional and just to make the plot look better
                    theme(plot.title = element_text(color = &quot;black&quot;,
                                                    size = 14,
                                                    face = &quot;bold.italic&quot;),
                          axis.title.x = element_text(size = 12,
                                                  face = &quot;bold&quot;),
                          axis.title.y = element_text(size = 12,
                                                      face = &quot;bold&quot;)) +
        # This adds in the linear regression line
                          geom_smooth(method = lm))
gg_len_vs_unique</code></pre>
<p><img src="/post/2017-11-18-intro-to-web-scraping_files/figure-html/plot%20uniqueness%20against%20length-1.png" width="672" /></p>
<p>This plot shows that as the number of total words increases, there’s a fairly sizeable dropoff in terms of percentage of those words that are unique. In our sample, just over 50% of the variation in song lyric uniqueness can be determined by the number of total words.</p>
</div>
</div>
<div id="making-word-clouds-from-song-lyrics" class="section level1">
<h1>Making Word Clouds from Song Lyrics</h1>
<p>Since all songs had more than half of their words repeated, it might be interesting to create a data visualization of exactly which words are being repeated most often. A word cloud allows us to do this in a qualitative manner.</p>
<p>We’ll be using the packages <a href="https://cran.r-project.org/web/packages/tm/tm.pdf">tm</a> and <a href="https://cran.r-project.org/web/packages/wordcloud/wordcloud.pdf">wordcloud</a> to do some specific text wrangling and to generate the word cloud image, respectively. Our first step is to change the list of song lyrics that we have now to one continuous vector with one element for each word.</p>
<pre class="r"><code># This will be automatically extended to the required length later
all_word_list &lt;- rep(NA, 20)

# A for loop to generate our desired vector
i &lt;- 1
for (song in swift_song_lyrics) {
  for (word_pos in 1:length(song)) {
    all_word_list[i] &lt;- song[word_pos]
    i &lt;- i + 1
  }
}

# To make our eventual cloud more interesting, let&#39;s restrict to only words 
# Of at least 4 characters
all_long_words &lt;- all_word_list[nchar(all_word_list) &gt;= 4]</code></pre>
<p>In order to make a wordcloud, you need something called a “corpus,” which is essentially just a collection of documents which contain text data. The tm package has the two functions we need to create that object, namely <code>VectorSource()</code>, whose output provides a suitable input to the second function, <code>Corpus()</code>.</p>
<pre class="r"><code>lyric_corpus &lt;- Corpus(VectorSource(all_long_words))
lyric_corpus</code></pre>
<pre><code>## &lt;&lt;SimpleCorpus&gt;&gt;
## Metadata:  corpus specific: 1, document level (indexed): 0
## Content:  documents: 2388</code></pre>
<p>As you can see, the corpus we created is composed of 2388 documents, each corresponding to one word of length 4 or more from the song lyrics. You can check that the <code>all_long_words</code> vector is the same length.</p>
<p>Now, we can make and display the plot itself by using the main function from the wordcloud package, <code>wordcloud()</code>.</p>
<pre class="r"><code># Set a seed so that the produced output is the same every time
set.seed(13)

# Use the wordcloud function. The first argument is the corpus we created earlier
wordcloud(lyric_corpus,
      # Next set the total number of words we want to appear on our plot. I&#39;ll choose 75.
          max.words = 75,
      # This argument ensures the most common words are in the center
          random.order = FALSE,
      # Plot with a selection of shades of blue for some visual appeal
          colors = c(&quot;deepskyblue&quot;,  &quot;deepskyblue3&quot;, &quot;dodgerblue&quot;,
                     &quot;dodgerblue3&quot;, &quot;light blue&quot;, &quot;turquoise&quot;))</code></pre>
<p><img src="/post/2017-11-18-intro-to-web-scraping_files/figure-html/plot%20a%20word%20cloud-1.png" width="672" /></p>
<p>Looking at this plot, we can see that shorter words (even after filtering to make sure all words are at least four letters) tend to be repeated more than the longer words, which appear mostly on the outskirts of the plot. “What” is the word repeated most often in the songs we’ve analyzed.</p>
<p>A final, but important, note about this process is that the <code>wordcloud()</code> function does not actually return anything. It prints out the plot, but does not save it anywhere. For this reason, the plot cannot be assigned to a variable and called later.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>I hope this example has showed you the power of being able to mine text data from the internet. I enjoyed seeing the results of my analysis, but to me the most exciting part is knowing that the data I used doesn’t exist in a convenient format anywhere else and therefore might not have been analyzed before. The necessary data (song lyrics) is all easy to find, but not easy at all to get into an R object without tons of copy and pasting.</p>
<p>The song data is just a small sampling of what you can do with the rvest package. Using the HTML tools I showed you, you can find tags and then harvest the text from almost website.</p>
</div>
<div id="reproducibility" class="section level1">
<h1>Reproducibility</h1>
<p>I hope that you, the reader, are able to follow along and reproduce my results where desired.</p>
<p>During my analysis, I used version 61.0.3163.100 of Google Chrome.</p>
<p>The only required packages are those listed at the very top of this post, and their version numbers (along with my version of R) are shown below. My version of RStudio is <code>1.0.153</code></p>
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>## R version 3.3.3 (2017-03-06)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X Yosemite 10.10.5
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] methods   stats     graphics  grDevices utils     datasets  base     
## 
## other attached packages:
##  [1] bindrcpp_0.2       ggplot2_2.2.1      wordcloud_2.5     
##  [4] RColorBrewer_1.1-2 tm_0.7-2           NLP_0.1-11        
##  [7] dplyr_0.7.4        stringr_1.2.0      rvest_0.3.2       
## [10] xml2_1.1.1        
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.13     plyr_1.8.4       bindr_0.1        tools_3.3.3     
##  [5] digest_0.6.13    evaluate_0.10.1  tibble_1.3.4     gtable_0.2.0    
##  [9] pkgconfig_2.0.1  rlang_0.2.0      yaml_2.2.0       parallel_3.3.3  
## [13] blogdown_0.9     xfun_0.4         httr_1.3.1       knitr_1.21      
## [17] grid_3.3.3       glue_1.2.0       R6_2.2.2         XML_3.98-1.9    
## [21] rmarkdown_1.11   bookdown_0.9     selectr_0.3-1    magrittr_1.5    
## [25] scales_0.5.0     htmltools_0.3.6  assertthat_0.2.0 colorspace_1.3-2
## [29] labeling_0.3     stringi_1.1.5    lazyeval_0.2.1   munsell_0.4.3   
## [33] slam_0.1-40</code></pre>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<ul>
<li><p>A website I used to learn about HTML:<br />
<a href="http://www.yourhtmlsource.com/starthere/whatishtml.html" class="uri">http://www.yourhtmlsource.com/starthere/whatishtml.html</a></p></li>
<li><p>A website I used to learn basic HTML formatting:<br />
<a href="https://www.w3schools.com/html/html_formatting.asp" class="uri">https://www.w3schools.com/html/html_formatting.asp</a></p></li>
<li><p>The linked website that I used to find the number of websites:<br />
<a href="https://www.theatlantic.com/technology/archive/2015/09/how-many-websites-are-there/408151/" class="uri">https://www.theatlantic.com/technology/archive/2015/09/how-many-websites-are-there/408151/</a></p></li>
<li><p>The referenced cran documentation of rvest:<br />
<a href="https://cran.r-project.org/web/packages/rvest/rvest.pdf" class="uri">https://cran.r-project.org/web/packages/rvest/rvest.pdf</a></p></li>
<li><p>The referenced cran documentation of stringr:<br />
<a href="https://cran.r-project.org/web/packages/stringr/stringr.pdf" class="uri">https://cran.r-project.org/web/packages/stringr/stringr.pdf</a></p></li>
<li><p>The referenced list of Taylor Swift studio albums:<br />
<a href="https://en.wikipedia.org/wiki/Taylor_Swift_discography#Studio_albums" class="uri">https://en.wikipedia.org/wiki/Taylor_Swift_discography#Studio_albums</a></p></li>
<li><p>The referenced stack overflow page on how to use gsub for \*:<br />
<a href="https://stackoverflow.com/questions/25424382/how-to-replace-single-backslash-in-r" class="uri">https://stackoverflow.com/questions/25424382/how-to-replace-single-backslash-in-r</a></p></li>
<li><p>The referenced resource on how to view HTML in Safari: <a href="http://www.socialmeteor.com/2013/03/04/how-to-view-html-source-in-safari-web-browser/" class="uri">http://www.socialmeteor.com/2013/03/04/how-to-view-html-source-in-safari-web-browser/</a></p></li>
<li><p>The referenced resource on how to view HTML in other browsers:<br />
<a href="https://www.computerhope.com/issues/ch000746.htm" class="uri">https://www.computerhope.com/issues/ch000746.htm</a></p></li>
<li><p>The referenced link to Selector Gadget in the Chrome Store:<br />
<a href="https://chrome.google.com/webstore/detail/selectorgadget/mhjhnkcfbdhnjickkkdbjoemdmbfginb" class="uri">https://chrome.google.com/webstore/detail/selectorgadget/mhjhnkcfbdhnjickkkdbjoemdmbfginb</a></p></li>
<li><p>The referenced Selector Gadget vignette:<br />
<a href="https://cran.r-project.org/web/packages/rvest/vignettes/selectorgadget.html" class="uri">https://cran.r-project.org/web/packages/rvest/vignettes/selectorgadget.html</a></p></li>
<li><p>A website I used to help me learn web scraping:<br />
<a href="https://quantmacro.wordpress.com/2016/04/30/web-scraping-for-text-mining-in-r/" class="uri">https://quantmacro.wordpress.com/2016/04/30/web-scraping-for-text-mining-in-r/</a></p></li>
<li><p>The main source of all my lyric data:<br />
<a href="http://www.songtexte.com/artist/taylor-swift-3bd6bc5c.html" class="uri">http://www.songtexte.com/artist/taylor-swift-3bd6bc5c.html</a></p></li>
<li><p>The referenced Berkeley Statistics website that explains about downloading a local copy:<br />
<a href="https://statistics.berkeley.edu/computing/r-reading-webpages" class="uri">https://statistics.berkeley.edu/computing/r-reading-webpages</a></p></li>
<li><p>A source I used for color names for my wordcloud:<br />
<a href="http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf" class="uri">http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf</a></p></li>
<li><p>A source I used to help me learn how to make a wordcloud:<br />
<a href="https://www.r-bloggers.com/building-wordclouds-in-r/" class="uri">https://www.r-bloggers.com/building-wordclouds-in-r/</a></p></li>
<li><p>The referenced cran documentation of the tm package:<br />
<a href="https://cran.r-project.org/web/packages/tm/tm.pdf" class="uri">https://cran.r-project.org/web/packages/tm/tm.pdf</a></p></li>
<li><p>The referenced cran documentation of the wordcloud package:<br />
<a href="https://cran.r-project.org/web/packages/wordcloud/wordcloud.pdf" class="uri">https://cran.r-project.org/web/packages/wordcloud/wordcloud.pdf</a></p></li>
<li><p>I created this report using R, RStudio, and RMarkdown, as well as all the packages loaded at the top of the page. Most were written by Hadley Wickham, tm was written by Ingo Feinerer, and wordcloud was written by Ian Fellows.</p></li>
</ul>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

